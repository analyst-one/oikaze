@use 'sass:map';
@use 'sass:string';
@use 'sass:list';
@use 'sass:math';

@use 'helpers';

$sets: () !default;
$default: 'default' !default;
$config: () !default;

$defaut-config: (
  base: 16px,
  enable-define: true,
  enable-em: true,
);

@use 'core' with (
  $sets: $sets,
  $default: $default,
  $config: map.merge($defaut-config, $config)
);

@forward 'core' show dangerously-add-set, $sets, $default;

// Resolves a token to its final value.
@function get($token) {
  $resolved: core.resolve-token($token);
  @return core.get-from-resolved($resolved);
}

// define variables.
@mixin define($token) {
  $resolved: core.resolve-token($token);
  $config: map.get($resolved, 'config');
  $enable-define: map.get($config, 'enable-define');

  @if ($enable-define != false) {
    @include core.define-var-from-resolved($resolved);
  }
}

// This mixin defines the specified tokens in the specified set. If no set is specified, it uses the current set.
@mixin css-definitions($set: null) {
  // css-definitions assumes the token is a set name
  $set: $set or core.$current;
  $token: $set;
  @if (not string.index($token, core.$set-char)) {
    $token: $token + core.$set-char;
  } @else {
    $split: string.split($token, core.$set-char);
    $set: list.nth($split, 1);
    $token: list.nth($split, 2);
  }

  @include scope($set) {
    @each $t in all($token) {
      @include define($t);
    }
  }
}

// This function takes a token and returns the custom property name that the token references.
@function prop($token) {
  $parsed: core.parse-token($token);
  @return map.get($parsed, 'var');
}

// Returns a percentage value for a given token.
@function percentage($token) {
  @return core.em-to-unit($token, 100%);
}

// Returns a rem value for a given token.
@function rem($token) {
  @return core.em-to-unit($token, 1rem);
}

// Returns a em value for a given token.
@function em($token) {
  @return core.em-to-unit($token, 1em);
}

// use alpha values in our color tokens.
@function alpha($token, $alpha: 1) {
  $resolved: core.resolve-token($token);
  $is-by-value: map.get($resolved, 'by-value');
  $value: map.get($resolved, 'value');

  @if (type-of($value) != 'color') {
    @error 'alpha() only works with colors';
  }

  @if (type-of($alpha) == 'string') {
    $alpha: percentage($alpha);
  } @else if (type-of($alpha) == 'number') {
    $alpha: helpers.to-percent($alpha);
  } @else {
    @error 'alpha() only accepts numbers or tokens for alpha';
  }

  @if ($is-by-value) {
    @return rgba($value, $alpha);
  }

  $var: map.get($resolved, 'var');
  @return color-mix(in srgb, var(#{$var}, $value) $alpha, transparent);
}

// This code is set a scope for tokens
@mixin scope($set: null) {
  $original-set: core.$current;
  @include core.set-current($set);
  @content();
  @include core.set-current($original-set);
}

@mixin media($tokens...) {
  $conditions: ();
  @each $token in $tokens {
    $parsed: core.resolve-token($token);
    $value: map.get($parsed, 'value');
    $query: if(type-of($value) == 'string', unquote($value), inspect($value));

    // TODO: error if not a value?
    $conditions: append($conditions, $query, 'comma');
  }

  @media #{$conditions} {
    @content;
  }
}

@function all($token: '') {
  $resolved: core.resolve-token($token);
  $map: map.get($resolved, 'value');
  $path: map.get($resolved, 'path');
  $by-value: map.get($resolved, 'by-value');

  @return core.inner-all($map, $by-value, $path...);
}
