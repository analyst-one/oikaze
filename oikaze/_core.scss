@use 'sass:map';
@use 'sass:string';
@use 'sass:color';
@use 'sass:math';
@use 'sass:list';

@use './helpers' as *;

$sets: () !default;
$default: 'default' !default;
$config: (
  enable-define: true,
  base: 16px,
  enable-em: true,
) !default;

$current: $default;

// TODO: make part of config
$ref-start: '{';
$ref-end: '}';
$set-char: ':';
$path-char: '.';
$key-char: '-';
$var-char: '$';
$em-suffix: '--em';
$base-key: 'base';
$config-key: 'CONFIG';

@function token-from-path($path...) {
  @return to-string($path, $path-char);
}

@function get-path-from-token($token) {
  @return string.split($token, $path-char);
}

// get values from a map with a path.
@function get-value($map, $path...) {
  @if not deep-map-check($map, $path...) {
    $current-set: map.get($sets, $current);
    @if $map != $current-set {
      @return get-value($current-set, $path...);
    }

    $default-set: map.get($sets, $default);
    @if $map != $default-set {
      @return get-value($default-set, $path...);
    }

    $token: token-from-path($path...);
    @error "Token not found: #{$token}";
  }
  @return deep-map-get($map, $path...);
}

// Gets a CSS variable key
@function create-var-from-keys($path...) {
  $var: to-string($path, '-');
  @return --#{$var};
}

@function get-rel-value-from-resolved($resolved) {
  $config: map.get($resolved, 'config');
  $base: map.get($config, $base-key) or 16px;
  
  @if ($base) {
    $value: map.get($resolved, 'value');
    @if ($base and type-of($value) == 'number') {
      @return to-rel($value, $base);
    }
  }

  @return null;
}

@mixin define-var-from-resolved($resolved) {
  $value: map.get($resolved, 'value');
  @if ($value) {
    $path: map.get($resolved, 'path');
    $config: map.get($resolved, 'config');
    $var: map.get($resolved, 'var');
    $def: map.get($resolved, 'def');

    #{$var}: $def or $value;

    @if (map.get($config, enable-em) and type-of($value) == 'number') {
      $rel: get-rel-value-from-resolved($resolved);
      @if ($rel) {
        #{$var}#{$em-suffix}: $rel;
      }
    }
  }
}

@function inner-all($map, $by-value, $path...) {
  $tokens: ();
  @each $key, $value in $map {
    $_path: list.append($path, $key);

    @if ($key != $config-key) {
      @if (type-of($value) == 'map') {
        $tokens: list.join($tokens, inner-all($value, $by-value, $_path...));
      } @else {
        $token: to-string($_path, $path-char);
        @if ($by-value) {
          $token: $var-char + $token;
        }
        $tokens: list.append($tokens, $token);
      }
    }
  }
  @return $tokens;
}

@function get-config($map, $path...) {
  $config: $config;

  @if (map.has-key($map, $config-key)) {
    $_config: map.get($map, $config-key);
    $config: map.deep-merge($config, $_config or ());
  }

  $_path: ();
  @each $key in $path {
    $_path: list.append($_path, $key);
    $config-path: list.append($_path, $config-key);

    @if (map.has-key($map, $config-path...)) {
      $_config: map.get($map, $config-path...);
      $config: map.deep-merge($config, $_config or ());
    }
  }

  @return $config;
}

@function em-to-unit($token, $unit) {
  $resolved: resolve-token($token);
  $is-by-value: map.get($resolved, 'by-value');
  $keys: map.get($resolved, 'keys');
  $value: map.get($resolved, 'value');
  $base: map.get($resolved, 'config', $base-key);

  @if (type-of($value) != 'number') {
    @error 'em() only works with numbers';
  }

  @if ($is-by-value) {
    $em: to-rel($value, $base);
    @return $em * $unit;
  }

  // Doesn't work with references
  $em: get-rel-value-from-resolved($resolved);
  $var: map.get($resolved, 'var');
  @return calc(var(#{$var}#{$em-suffix}, $em) * $unit);
}

@function get-set-by-name($set-name) {
  $set-name: $set-name or $current or $default;
  @if ($set-name == '') {
    $set-name: $current or $default;
  }
  @if (not map.has-key($sets, $set-name)) {
    @error "Set not found: #{$set-name}";
  }
  @return map.get($sets, $set-name);
}

// This code parses a token string into a map of useful information.
// The map contains the following keys:
//   complete: the complete token string
//   raw: the raw token string
//   token: the token without the set
//   set: the set
//   path: the path as a list of keys
//   var: the variable
//   by-value: whether the token is a value or not
@function parse-token($token) {
  $raw: $token;
  $set: $current;

  @if (string.index($token, $set-char)) {
    $split: string.split($token, $set-char);
    $set: list.nth($split, 1);
    $token: list.nth($split, 2);
  }

  $by-value: string.index($token, $var-char) == 1;
  @if ($by-value) {
    $token: string.slice($token, 1 + string.length($var-char));
  }

  $path: get-path-from-token($token);
  $var: null;
  @if (list.length($path) > 0) {
    $var: create-var-from-keys($path...);
  }

  $complete: $set + $set-char + $token;

  @return (
    complete: $complete,
    raw: $raw,
    token: $token,
    set: $set,
    path: $path,
    var: $var,
    by-value: $by-value
  );
}

@function resolve-reference($value) {
  $def: $value;

  @if (type-of($value) == 'string') {
    $by-value: string.index($value, $var-char) == 1;
    @if ($by-value) {
      $value: string.slice($value, 1 + string.length($var-char));
    }

    @if (
      starts-with($value, $ref-start) and ends-with($value, $ref-end)
    ) {
      $len: string.length($value);
      $token: str-slice(
        $value,
        1 + string.length($ref-start),
        -1 - string.length($ref-end)
      );
      $token: if($by-value, $var-char + $token, $token);

      $ref: resolve-token($token);
      $value: map.get($ref, 'value');
      $def: get-from-resolved($ref);
    }
  } @else if (type-of($value) == 'list') {
    $list: $value;
    $value: ();
    $def: ();
    $sep: list.separator($list);

    @each $item in $list {
      $resolved: resolve-reference($item);
      $value: list.append($value, map.get($resolved, 'value'), $sep);
      $def: list.append($def, map.get($resolved, 'def'), $sep);
    }
  }

  @return (
    value: $value,
    def: $def
  );
}

// Resolves a token
@function resolve-token($token) {
  $parsed: parse-token($token);

  $token: map.get($parsed, 'token');
  $set-name: map.get($parsed, 'set');
  $path: map.get($parsed, 'path');

  $map: get-set-by-name($set-name);
  $value: $map;
  $final: $value;
  $def: $value;
  $config: get-config($map, $path...);

  @if ($token and $token != '') {
    $value: get-value($map, $path...);
    $resolved: resolve-reference($value);
    $value: map.get($resolved, 'value');
    $def: map.get($resolved, 'def');
  }

  @return map.merge(
    $parsed,
    (
      // The fully resolved value of the token
      value: $value,
      // The config of the token
      config: $config,
      // The map containing the token
      map: $map,
      // Definition of the token
      def: $def
    )
  );
}

@function get-from-resolved($resolved) {
  $is-by-value: map.get($resolved, 'by-value');
  $value: map.get($resolved, 'value');
  $def: map.get($resolved, 'def');
  
  @if ($is-by-value) {
    @return $value;
  }
  
  $var: map.get($resolved, 'var');
  @return var(#{$var}, $value);
}

@mixin dangerously-add-set($set-name, $map) {
  $sets: map.set($sets, $set-name, $map) !global;
}

@mixin set-current($set-name: $default) {
  @if (not map.has-key($sets, $set-name)) {
    @error "'#{$set-name}' is not defined.";
  }
  $current: $set-name !global;
}
